# 044前缀树原理和代码详解
哈希表可以查有多少数组以a开头，不能查多少数组以ac开头，前缀树可以

前缀树又叫字典树，英文名trie:
每个样本 都从头节点开始 根据 前缀字符或者前缀数字 建出来的一棵大树，就是前缀树
没有路就新建节点；已经有路了，就复用节点
前缀树的使用场景：需要根据前缀信息来查询的场景
前缀树的优点：根据前缀信息选择树上的分支，可以节省大量的时间
前缀树的缺点：比较浪费空间，和总字符数量有关
前缀树的定制：pass、end等信息

前缀树的实现方式：
1）类描述的实现方式（动态结构）。不推荐！虽然最常用。
1．路的可能性范围较小，用 固定数组 实现路
2．路的可能性范围较大，用 哈希表 实现路
2）静态数组的实现方式。推荐！不仅笔试，就连比赛也能保证使用。
1．一切都是静态数组来实现，提交准备好够用的空间
2．如果路的可能性范围较大，就用每一位的信息建树。下节课前缀树的题目里展示

### 前缀树原理和代码详解



力扣1804 实现前缀树 会员
题目
实现前缀树 Trie 类：
1.Trie(）初始化前缀树对象。
2. void insert(String word）将字符串 word 插入前缀树中。
3.  int search(String word）返回前缀树中字符串 word 的实例个数。
4. int prefixNumber(String prefix) 返回前缀树中以 prefix 为前缀的字符串个数
5. void delete(String word）从前缀树中移除字符串 word。

>构造TrieNode类，一个pass，一个end，和一个数组用来记录前往下级各节点的路，用字符的ASCII码差来表示
删除时利用剪枝
```py 
class TrieNode:
    def __init__(self):
        self.p = 0
        self.end = 0
        self.nexts = [None] * 26

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        node.p += 1
        for char in word:
            path = ord(char) - ord('a')
            if node.nexts[path] is None:
                node.nexts[path] = TrieNode()
            node = node.nexts[path]
            node.p += 1
        node.end += 1

    def delete(self, word):
        if self.search(word) > 0:
            node = self.root
            node.p -= 1
            for char in word:
                path = ord(char) - ord('a')
                if node.nexts[path] is not None:
                    if node.nexts[path].p == 1:
                        node.nexts[path] = None
                        return
                    node.nexts[path].p -= 1
                    node = node.nexts[path]
            node.end -= 1


    def search(self, word):#找单词
        node = self.root
        for char in word:
            path = ord(char) - ord('a')
            if node.nexts[path] is None:
                return 0
            node = node.nexts[path]
        return node.end

    def prefixNumber(self, pre):#找前缀
        node = self.root
        for char in pre:
            path = ord(char) - ord('a')
            if node.nexts[path] is None:
                return 0
            node = node.nexts[path]
        return node.p

# 创建 Trie 实例  
trie = Trie()  

# 插入单词  
words_to_insert = ["apple", "app", "apricot", "banana"]  
for word in words_to_insert:  
    trie.insert(word)  

# 测试查找特定单词  
print("Count of 'apple':", trie.search("apple"))  # 应该输出 1  
print("Count of 'app':", trie.search("app"))      # 应该输出 1  
print("Count of 'apricot':", trie.search("apricot"))  # 应该输出 1  
print("Count of 'banana':", trie.search("banana"))  # 应该输出 1  
print("Count of 'orange':", trie.search("orange"))  # 应该输出 0  

# 测试查找前缀  
print("Count of words starting with 'app':", trie.prefixNumber("app"))  # 应该输出 2 ('apple', 'app')  
print("Count of words starting with 'ap':", trie.prefixNumber("ap"))    # 应该输出 3 ('apple', 'app', 'apricot')  
print("Count of words starting with 'ba':", trie.prefixNumber("ba"))    # 应该输出 1 ('banana')  
print("Count of words starting with 'or':", trie.prefixNumber("or"))    # 应该输出 0  

# 删除单词  
trie.delete("app")  # 删除 'app'  
print("Count of 'app' after deletion:", trie.search("app"))  # 应该输出 0  
print("Count of words starting with 'app' after deletion:", trie.search("app"))  # 应该输出 1 (still contains 'apple')  

# 删除单词 'apple'  
trie.erase("apple")  
print("Count of 'apple' after deletion:", trie.search("apple"))  # 应该输出 0  
print("Count of words starting with 'app' after deletion:", trie.prefixNumber("app"))  # 应该输出 0 (no more words with 'app')

```
静态空间方法
牛客
nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b
维护一个二维数组tree[n][3],常量cnt,一个pass,一个end
0行不用，从第1行开始。
```py
class TrieTree:
    MAXN = 150001
    def __init__(self):
        
        self.tree = [[0] * 26 for _ in range(self.MAXN)] 
        self.p = [0] * self.MAXN
        self.end = [0] * self.MAXN
        self.cnt = 0

    def build(self):
        self.cnt = 1

    def insert(self, word):
        cur = 1
        self.p[cur] += 1
        for char in word:
            path = ord(char) - ord('a')
            if self.tree[cur][path] == 0:
                self.cnt += 1
                self.tree[cur][path] = self.cnt
            cur = self.tree[cur][path]
            self.p[cur] += 1
        self.end[cur] += 1

    def search(self, word):
        cur = 1
        for char in word:
            path = ord(char) - ord('a')
            if self.tree[cur][path] == 0:
                return 0
            cur = self.tree[cur][path]
        return self.end[cur]

    def prefix_number(self, prefix):
        cur = 1
        for char in prefix:
            path = ord(char) - ord('a')
            if self.tree[cur][path] == 0:
                return 0
            cur = self.tree[cur][path]
        return self.p[cur]
    
    def delete(self, word):
        if self.search(word) > 0:
            cur = 1
            for char in word:
                path = ord(char) - ord('a')
                if self.p[self.tree[cur][path]] == 1:
                    self.tree[cur][path] = 0
                    return 
                self.p[self.tree[cur][path]] -= 1
                cur = self.tree[cur][path]
            self.end[cur] -= 1

    def clear(self):
        for i in range(1, self.cnt + 1):
            self.tree[i] = [0] * 26
            self.end[i] = 0
            self.p[i] = 0

def main():
    import sys

    data = sys.stdin.read().strip().splitlines()#按行分割
    
    trie = TrieTree()
    idx = 0
    while idx < len(data):
        trie.build()
        m = int(data[idx])
        idx += 1
        for _ in range(m):
            splits = data[idx].split()#把一行分成几个
            op = int(splits[0])
            if op == 1:
                trie.insert(splits[1])
            elif op == 2:
                trie.delete(splits[1])
            elif op == 3:
                print("YES" if trie.search(splits[1]) > 0 else "NO")
            elif op == 4:
                print(trie.prefix_number(splits[1]))
            idx += 1
        trie.clear()

if __name__ == "__main__":
    main()
```



# 45
题目1:两个数组特征值求前缀
https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932
牛牛和他的朋友们约定了一套接头密匙系统，用于确认彼此身份。密匙由一组数字序列表示，两个密匙被认为是一致的，如果满足以下条件：
密匙 b 的长度不超过密匙 a 的长度。
对于任意 0 <= i < length(b)，有 b[i+1] - b[i] == a[i+1] - a[i]。
现在给定了m个密匙 b 的数组，以及n个密匙 a 的数组。请你返回一个长度为 m 的结果数组 ans，表示每个密匙b都有多少一致的密匙a。 

```py
class Solution:
    MAXN = 2000001
    def __init__(self):    
        self.tree = [[0] * 12 for _ in range(self.MAXN)] 
        self.p = [0] * self.MAXN
        self.cnt = 0

    def countConsistentKeys(self , b: List[List[int]], a: List[List[int]]) -> List[int]:
        self.build()
        ans = []
        #[3,6,50,10] -> "3#44#-40#"
        for nums in a:
            builder = []
            for i in range(1,len(nums)):
                builder.append(str(nums[i] - nums[i - 1]))
            k = '#'.join(builder) + '#'
            self.insert(k)
        for nums in b:
            builder = []
            for j in range(1, len(nums)):
                builder.append(str(nums[j] - nums[j - 1]))
            q = '#'.join(builder) + '#'
            ans.append(self.count(q))
        
        self.clear()
        return ans
    
    def build(self):
        cnt = 1

    #  '0' ~ '9' 10个 0~9
	#  '#' 10
	#  '-' 11
    def path(self, cha):
        if cha == '#':
            return 10
        elif cha == '-':
            return 11
        else:
            return ord(cha) - ord('0')

    def insert(self, word):
        cur = 1
        self.p[cur] += 1
        for char in word:
            path = self.path(char)
            if self.tree[cur][path] == 0:
                self.cnt += 1
                self.tree[cur][path] = self.cnt
            cur = self.tree[cur][path]
            self.p[cur] += 1
        
    def count(self, pre):
        cur = 1
        for char in pre:
            path = self.path(char)
            if self.tree[cur][path] == 0:
                return 0
            cur = self.tree[cur][path]
        return self.p[cur]

    def clear(self):
        for i in range(1, self.cnt + 1):
            self.tree[i] = [0] * 12
            self.p[i] = 0
```

题目2:数组中两个数的最大异或值
前缀树做法 & 哈希表做法

最好是让结果高位是1

 

 


> Written with [StackEdit中文版](https://stackedit.cn/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4ODI3NjcyMTEsMjM3MTMwNjgsMzU3Mj
cwMTY0LC01OTYxNzk4NjgsMTc5OTMyMjEwMF19
-->