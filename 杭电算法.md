# 第一课
### 快速幂
指数很大时，底数平方，指数减半
注意爆int风险
# 第二课 贪心

### Havel-Hakimi定理
由非负整数组成的非增序列S:d,d2,...,dn(n≥2,d1≥1)
是可图的，当且仅当序列S1:d2-1,d3-1,...,dd1+1-1,dd1+2,...,dn 是可图的。
>7,7,4,3,3,3,2,1可图的话
>当且仅当6，3，2，2，2，1，0可图
>3，1，1，1，0，-1   不可图
>所以原序列不可图
>
# 第三课 并查集
### 带路径压缩的查找操作 
当进行查找操作时，不仅仅是找到某个元素所在集合的代表元素，还会同时将查找路径上的元素都直接指向代表元素，从而压缩了查找路径的长度。
```c
//意思是查出每一个元素的代表，将其直接连接
find3(x)
{
	if(Set[x]!=x)
		Set[x]=find3(Set[x]);
	return Set[x];
｝
```
# 第四课 递推
总结：递推求解的基本方法 
■首先，确认：能否容易的得到初始状态的解？
■然后，假设：规模不大于N-1的状态已经得到解决。
■最后，重点分析：当规模扩大到N时，如何枚举出所有的情况，然后用子问题的状态（F(1)、F(2)、...F(N-1))表示出最终的状态F(N)（即：状态转移）。
### 卡特兰数列
卡特兰数的前面若干项分别是：1,2,5,14, 42,132,
# 第五课 动态规划
小结：DP的思想和特点 
基本思想：
如果各个子问题不是独立的（即：重复的），不同的子问题的个数只是多项式量级（即：有限的），如果我们能够保存已经解决的子问题的答案（一般用数组），而在需要的时候再找出已求得的答案，这样就可以避免大量的重复计算。
# 第六课 背包问题

### 一、01背包
■01背包（最基础的背包问题）:
. 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。
■ 问题特点：每种物品仅有一件，可以选择放或不放；
.思考：在每个物品都有可能被选中的前提下，如何构造"子问题"?
■无序变有序的方法：依次考虑前1、前2、前3..．前i个物品；
■ 状态定义： f[i][v］表示前i件物品放入一个容量为v的背包可以获得的最大价值。

### 二、完全背包
完全背包特点：一种物品可以取无数个
■可否转化成01背包问题？
■朴素的转化方式是？
■ 回忆01背包为何要对容量按照逆序循环？
■ 和01背包类似，不过就是正着写
■深度思考：这类能不能达到的问题应该怎么实现？

### 三、多重背包
■ 多重背包特点：
■一种物品有 C 个
（既不是固定的1个，也不是无数个）


### 四、二维费用背包
◇二维费用背包问题：
■ 对于每件物品，具有两种不同的费用；
选择这件物品必须同时付
出这两种代价；对于每种代价都有一个可付出的最大值（比如，背包容量、最大承重），求怎样选择物品可以得到最大的价值。
■ 设第i件物品所需的两种代价分别为a[i］和 b[i]，两种代价可付
出的最大值（比如体积和重量）分别为V和U，物品的价值为w[i]。
■ 对应算法：费用加了一维，只需状态也加一维即可！
■设f[i][v][u］表示前i件物品付出两种代价分别为v和u时可获得的最大价值，状态转移方程则为：
f[i][v][u]=max[f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}

# 第七课 bfs

# 第八课 dfs
### 求全排列
递归，非常难
```python
#!/usr/bin/python
# Write Python 3 code in this online editor and run it.

 
def dfs(step):
    global n, num_list, visited
    if step == n + 1:
        print(*num_list[1:])
        return
    for i in range(1, n + 1):
        if not visited[i]:
            num_list[step] = i
            visited[i] = True
            dfs(step + 1)
            visited[i] = False

while True:
    try:
        n = int(input())
        num_list = [0] * (n + 1)
        visited = [False] * (n + 1)
        dfs(1)
    except:
        break

```
后面一题没听

# 第九课 二分匹配
### 最小顶点覆盖 
结论：
二分图的最小顶点覆盖数＝=二分图的最大匹配数
关键：求二分图的最大匹配数
### DAG图的最小路径覆盖 
DAG图的最小路径覆盖数＝节点数（n)﹣最大匹配数（m)

### 二分图的最大独立集
二分图的最大独立集数＝节点数（n)- 最大匹配数（m)
关键：求二分图的最大匹配数

# 第十课 组合博弈
### 选子游戏
找比胜点和必败点
###  求sg值没看懂

# 第十一课 stl 先不学
# 第十二课  拓扑排序
# 第十三课 二分答案
有些式子不单调可以求导，用三分法

二分答案常见步骤：
1、证明问题的单调性之所在；
2、确定问题的单调区间上下界；
3、设计check(）函数，方便每一次二分求解的时候，判断当前值是否满足指定的限定条件；
4、在单调区间上下界之内二分答案（通过循环实现二分）:
若当前值不行，缩小一半的查询区间，继续查询；
若当前值可行，为候选解，但继续缩小一半区间求更优解；
当单调区间查询完毕（或已达到指定精度），查找结束。

# 第十四课 最短路径
Dijkstra算法的基本思想
路径长度第三短的路径特点：
它可能有三种情况：
1、直接从源点到该点（只含一条弧）;
2、从源点经过顶点v，再到达该顶点（由两条弧组成）;
3、从源点经过顶点v2，再到达该顶点。
其中：1、2在上一步已经做过比较
所以﹣﹣每次只需要比较2个值！

Dijkstra算法的具体步骤
0）准备工作：
设置辅助数组Dist，其中每个分量Dist[k］表示：当前所求得的从源点到其余各顶点 k 的最短路径。
1）在所有从源点出发的弧中选取一条权值最小的
弧，即为第一条最短路径
2）修改其它各顶点的Dist[k］值。（为什么？)
具体操作：假设求得最短路径的顶点为u，若
Dist[u]+Map[u][k]<Dist[k]
则将 Dist[k］改为 Dist[u]+ Map[u][k]

状态转移方程？
理论表示：Dist[k]=min(Map[i][k]+Dist[i])
其中，i为已经求出最短路的节点编号。
假设u为刚刚求得的最短路节点，则：
实际编程：Dist[k]=minDist[kMap[u][N-Dist[g]
> Written with [StackEdit中文版](https://stackedit.cn/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbNjY0MDMwMTEyXX0=
-->